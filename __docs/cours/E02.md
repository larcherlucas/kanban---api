# S06E02 – REST API & Architecture

## Menu du jour

### Matin COURS

- Correction
  - Gestion de projet (user stories/wireframes)
  - Modélisation (MCD/MLD)

- Modélisation
  - Créer la BDD okanban
  - Modèles Sequelize (`List`)
  - Script JS de creation des tables (DDL)
  - Script JS d'échantillonnage (DML)

- Architecture
  - ECMAScript Modules (ESM)
  - Serveur Express (`GET /lists`)
  - Spécifications REST (bonus)

- Gitflow
  - Mise en place

### Après-midi ATELIER

- Modèles Sequelize
  - Card
  - Tag
  - Associations
  - Compléter la création des tables
  - Compléter l'échantillonnage des tables

- API REST
  - GET /lists
  - GET /lists/:id
  - POST /lists
  - PATCH /lists/:id
  - DELETE /lists

## Git flow

- ajouter un `remote` nommé `correction` (à côté du remote de base qui est `origin`)
  
    ```bash
    git remote add correction git@github.com:O-clock-Muffin/S06-okanban-api-BLUE-FabienTavernier.git
    ```

- on met à jour la branche `master` pour qu'elle suive celle du repo `correction` :

    ```bash
    git pull correction master --allow-unrelated-histories --no-edit -X theirs
    ```

  - `--allow-unrelated-histories` :
    permet le pull de commits qui viennent d'un autre repo

  - `--no-edit` :
    évite de demander de ré-écrire le message du commit en ouvrant VIM ou nano

  - `-X theirs` :
    en cas de conflit (parce que par erreur j'ai _commit_ des choses
    sur `master` qui sont antagonistes avec ce qu'à fait le formateur),
    on garde la version du formateur

- chaque jour, on crée une nouvelle branche pour faire l'atelier ;  
  ex : `git switch -c jour2`

- on travaille sur cette branche puis on _push_ en faisant :
  `git push origin jour2`

    > ON NE TRAVAILLE PAS SUR `MASTER`/`MAIN`

- pour la suite, on fera un `git pull correction master` pour récupérer les énoncés
  et corrections

## Correction

> créer et coder sur une branche `correction-jour1` (à _merge_ en fin de matinée → PR)

### _User stories_

→ voir `__docs/ressources/conception/user-stories.md`

### MCD

→ voir `__docs/ressources/conception/mcd/`

### Wireframe

→ voir `__docs/ressources/conception/wireframe/`

### Base de données

> [PostgreSQL](__docs/ressources/bdd/postgres_commands.md)

```bash
sudo -i -u postgres psql
```

```SQL
CREATE USER okanban WITH PASSWORD 'okanban';
CREATE DATABASE okanban OWNER okanban;
```

## C'est notre projet

### Initialiser le projet

#### PNPM

> `NPM`, `Yarn`, `PNPM` ?

On aura des dépendances, on initialise PNPM  
→ `pnpm init`

Type : **module** → on va travailler avec des ESM !

Dépendances :

- `dotenv`
- `pg`
- `sequelize`

#### Variables d'environnement

`.env` (faire aussi le `.env.example`)

```text
DB_HOST=localhost
DB_NAME=database
DB_USER=user
DB_PWD=secret
DB_DRIVER=postgres
```

ou

```text
PG_URL=postgres://<user>:<password>@<host>/<database>
```

#### Git

Git :

- `.gitignore` pour les modules (`node_modules`) et le `.env`

#### ESLint

Configuration avec prise ne charge des ESM

```json
{
  "env": {
    "browser": true,
    "es6": true,
    "node": true
  },
  "parserOptions": {
    "ecmaVersion": 2022,
    "sourceType": "module"
  },
  "extends": "eslint:recommended",
  "rules": {
    "indent": ["error", 2],
    "semi": ["error", "always"]
  },
  "ignorePatterns": ["**/dist"]
}
```

### Client Sequelize

On va se connecter à la BDD  
→ voir `src/sequelize-client.js`

On peut tester la connexion  
→ `sandbox/db_cnx_test.js`

### _Model_ Liste

→ voir `src/models/list.model.js`

#### Et les _timestamps_ ?

On n'oublie de rajouter les « timestamps » (`created_at` et `updated_at`).

« Ça coûte pas grand chose » et ça peut nous servir à plein de choses :

- trier les cartes par dte de création
- savoir depuis combien de temps la carte X possède le label « urgent »  
  → ouverture vers potentielle fonctionnalité d'alerte
- …

Dans Sequelize ?  
Tout est automatique !  
→ <https://sequelize.org/docs/v6/core-concepts/model-basics/#timestamps>

### Synchronisation

→ voir `src/migrations/01.createTables.js`

### Échantillonnage

→ voir `src/migrations/02.seedTables.js`

On peut tester la récupération des listes  
→ `sandbox/db_lists_test.js`

> au lieu de lancer les fichiers à la main,
> on peut créer des scripts PNPM :
>
> ```json
> "db:create": "node ./src/migrations/01.createTables.js",
> "db:seed": "node ./src/migrations/02.seedTables.js"
> "db:reset": "pnpm db:create && pnpm db:seed",
> ```

## COURS

### REST API

> <https://www.restapitutorial.com/lessons/whatisrest.html>  
> <https://fr.wikipedia.org/wiki/Representational_state_transfer>

_Representational State Transfer_ (REST) désigne un groupe de contraintes (6)
concernant l'architecture logicielle destiné à apporter aux systèmes
efficacité, fiabilité et scalabilité.  
Un système est appelé _RESTful_ lorsqu'il adhère à ces contraintes.

#### Interface uniforme

Elle simplifie et découple l'architecture,
ce qui permet à chaque composant d'évoluer indépendamment. 4 principes, dont :

Une Rest API est basée sur des **ressources** caractérisées par :

- des noms (nos entités ! – `list`, `card`, `tag`)
- identifiées par des
  [URIs](https://selvi48zenith.files.wordpress.com/2021/09/the-illustration-of-the-url-urn-and-uri-26.png)
  (_Uniform Resource Identifier_)

Exemple :

- `http://localhost:3000/lists`
- `http://localhost:3000/lists/42`

Plusieurs URIs peuvent faire référence à la même ressource pour différents types
d'opérations, on les distingue alors grâce aux [verbes HTTP](../ressources/routes/http_verbs.md)
(`GET`, `POST`, `DELETE`…).

> Les SOAP API, elles, se basent sur des actions et sont caractérisées par des verbes.
> Elle se basent sur des paramètres de requêtes et non sur des URIs
>
> ```js
> request_headers = {"content-type": "text/xml"}
> request_body =  "<?xml version=\"1.0\"?>"
> request_body += "<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">"
> request_body += "<soap:Header></soap:Header>"
> request_body += "<soap:Body>"
> request_body += "<m:GetBook>"
> request_body += "<m:BookId>123</m:BookId>"
> request_body += "</m:GetBook>"
> request_body += "</soap:Body>"
> request_body += "</soap:Envelope>"
> response = requests.post(
>   "http://www.example.com/exampleapi",
>   data=request_body,
>   headers=request_headers
> )
> ```

#### Client–serveur

Les responsabilités sont séparées entre le client et le serveur.  
Exemple : le client n'est pas concerné par le stockage des données.

#### Sans état

Deux appels sont indépendants :
la communication client–serveur s'effectue sans conservation de l'état
de la session de communication sur le serveur entre deux requêtes successives.
L'état de la session est conservé par le client et transmis à chaque nouvelle requête.

#### Avec mise en cache

Les réponses peuvent être mises en cache.

#### En couche

Un client ne peut habituellement pas dire s'il est connecté
directement au serveur final ou à un serveur intermédiaire.  
Les serveurs intermédiaires peuvent améliorer l'extensibilité du système
en mettant en place une répartition de charge et un cache partagé.
Ils peuvent aussi renforcer les politiques de sécurité.

#### Avec un code à la demande (optionnel)

Les serveurs peuvent temporairement étendre ou modifier les fonctionnalités
d'un client en lui transférant du code exécutable (scripts JS par ex.).

#### En bref

Une API REST, c'est un ensemble de routes :

- `GET https://mon-api.com/cards` : obtenir toutes les cartes de l'application
- `POST https://mon-api.com/cards` : ajouter une carte
- `PUT https://mon-api.com/cards/3` : modifier la carte 3
- `GET https://mon-api.com/lists/5/cards` : obtenir les cartes de la liste 5

> voir la [documentation de l'API Spotify](https://developer.spotify.com/documentation/web-api)
> ou celle de [JSON Placeholder](https://jsonplaceholder.typicode.com/)

### Liste de nos routes

→ voir `specifications/api-base-endpoints.md`
